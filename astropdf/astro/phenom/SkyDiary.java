package astropdf.astro.phenom;

import static astropdf.util.LogUtil.log;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import astropdf.config.Config;
import astropdf.config.ConfigFromFile;
import astropdf.util.DataFileReader;
import astropdf.util.Util;

/**
Daily phenomena generated by the MICA tool.
 
 Example input:
<pre>
                                                   d  h
New Moon                                 2016 Oct  1 00    401579.717 km
Spica in conjunction with Moon           2016 Oct  2 04    5.78° South
</pre>

<P>Input is generated using Multiyear Interactive Computer Almanac (MICA) software, from the US Naval Observatory.

<P>The output is to the nearest hour only.

<P>In <code>config.ini</code>, the setting <code>sky_diary_ignorable_objects</code> allows you to suppress events for some objects,
simply by detecting their name in the description of the event.

<P>
Steps to get the source data from MICA:
<ul>
  <li>Calc -&gt; Phenomena -&gt; Search -&gt; the full time frame in config.ini.
  <li>Use an offset from UT, to match config.ini.
  <li>File -&gt; Save as ASCII 
  <li>Export as text; to be safe, open in Notepad and re-save as UTF-8.
  <li>Save the file to the directory containing this class.
</ul> 
<P>WARNING: eclipses and transits of Venus and Mercury aren't exported using the above technique. 
They are separate.
*/
public final class SkyDiary {
  
  public static void main(String[] args) {
    SkyDiary skyDiary = new SkyDiary();
    Config config = new ConfigFromFile().init();
    List<DiaryEvent> events = skyDiary.allPhenomena(config);
    for (DiaryEvent event : events) {
      System.out.println(event);
    }
  }

  /** Data exported from the MICA tool. */ 
  public static final String INPUT_FILE_MICA_EXPORT = "phenomena_utf8.txt";

  /**
   List of sky phenomena as generated by the MICA tool.
   The export from the tool SHOULD MATCH the configured offset and date-range, but that is not enforced here.
   
   <P>The caller will later 'table-ize' this list, using date-time as the key.
   The reason for not returning a map here is that N data sets will later need to be consolidated into 
   the same table. That is, the flow is:
   <pre>N lists of events -&gt; 1 list of events -&gt; 1 table (keyed by date-time)</pre>
   It's easier to do that consolidation into a table structure once, instead of several times.  
  */
  public List<DiaryEvent> allPhenomena(Config config){
    List<DiaryEvent> result = new ArrayList<>();
    DataFileReader reader = new DataFileReader();
    List<String> lines =  reader.readFileUTF8(this.getClass(), INPUT_FILE_MICA_EXPORT);
    lines = lines.subList(8, lines.size()); //discard header lines
    for(String line : lines){
      if (Util.textHasContent(line)){ 
        DiaryEvent prevEvent = result.isEmpty() ? null : result.get(result.size()-1);
        Optional<DiaryEvent> event = parseEvent(line, prevEvent, config);
        if (event.isPresent()){
          result.add(event.get());
        }
      }
    }
    log("Num events: " + result.size());
    log("Num abandoned asteroid events: " + countIgnoredEvents);
    return result;
  }

  // PRIVATE
  
  private int countIgnoredEvents;
  private static final String WS = "\\s+";
  private static final String CONJUNCTION = " in conjunction with ";
  
  /** Translate the English month name into a number. */
  private static final Map<String, Integer> MONTH = new LinkedHashMap<>();
  static {
    MONTH.put("Jan", 1);
    MONTH.put("Feb", 2);
    MONTH.put("Mar", 3);
    MONTH.put("Apr", 4);
    MONTH.put("May", 5);
    MONTH.put("Jun", 6);
    MONTH.put("Jul", 7);
    MONTH.put("Aug", 8);
    MONTH.put("Sep", 9);
    MONTH.put("Oct", 10);
    MONTH.put("Nov", 11);
    MONTH.put("Dec", 12);
  }

  /** Can return null. */
  private Optional<DiaryEvent> parseEvent(String line, DiaryEvent previousEvent, Config config){
    Optional<DiaryEvent> result = Optional.empty();
    //Spica in conjunction with Moon           2016 Oct  2 04    5.78° South
    //log("      Event line: " + line);
    String text1 = line.substring(0, 41).trim(); //Spica in conjunction with Moon        
    String text2 = line.substring(55).trim(); //   5.78° South
    String date = line.substring(41,52); //2016 Oct  2
    String hour = line.substring(53,55); // 04
    
    if (hasIgnorableObject(text1, config)){
      //abandon the line
      ++countIgnoredEvents;
    }
    else {
      DiaryEvent event = new DiaryEvent();
      String[] parts = date.split(WS);
      event.when = LocalDateTime.of(inty(parts[0]), MONTH.get(parts[1]), inty(parts[2]), inty(hour), 0);
      event.text = rephraseConjunctions(text1, text2).trim();
      event.isImportant = containsImportantWord(event.text);
      result = Optional.of(event);
    }
    return result;
  }
  
  private Integer inty(String num) {
    //strip leading zeros
    String val = num.startsWith("0") ? num.substring(1) : num;
    return Integer.valueOf(val);
  }
  
  private boolean hasIgnorableObject(String text1, Config config){
    boolean result = false;
    for(String ignorableObjectName : config.skyDiaryIgnorableObjects()){
      if (text1.contains(ignorableObjectName)){
        result = true;
        break;
      }
    }
    return result;
  }
  
  /**
   The incoming text:
   
    text1: 'Spica in conjunction with Moon'        
    text2: '5.78° South'
    
    is changed to 'Spica 5.78° S of Moon'
  */
  private String rephraseConjunctions(String text1, String text2){
    String result = text1 + " " + text2; 
    if (text1.contains(CONJUNCTION)){
      String[] parts = text1.split(WS);
      String[] degreeParts = text2.split(WS);
      result = parts[0] + " " + degreeParts[0]  + degreeParts[1].substring(0, 1) + " of " + parts[parts.length-1];
    }
    return result;
  }
  
  private static final List<String> IMPORTANT_WORDS = new ArrayList<>();
  static {
    IMPORTANT_WORDS.add("Solstice");
    IMPORTANT_WORDS.add("Equinox");
  }
  private boolean containsImportantWord(String text) {
    boolean result = false;
    for(String imp : IMPORTANT_WORDS) {
      if (text.toLowerCase().contains(imp.toLowerCase())) {
        result = true;
        break;
      }
    }
    
    return result;
    
  }

}